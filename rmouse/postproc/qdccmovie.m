function qdccmovie(r,strmTypes,varargin)
% ** function ccmovie(r,strmTypes,varargin)
% standalone 'CC movie' generating function for fields of data structure r 
% as generated by rmouse.m 
% Needs DS and AP as global vars in the workspace
% r                results struct of rmouse.m
% strmTypes        any (comination) of 'delta','theta','gamma','thetaLoEnv','thetaHiEnv','gammaEnv'
% beh, 'expl'      any of 'imm','expl','groo'
% 
% chanComb         char arr, 'neigh'     'neigh' - nearest neighbor (line plots)
%                                        'princ' - all vs. principal channel (line plots)
%                                        'all'   - all, color-coded matrix plot
% interpol, 0      


% extension: look for recurring patterns using PC, make movie
% improvement: combine all behavs and set in chronological order
% options: interpolation, smoothing

global DS AP 

beh='expl';
chanComb='neigh';
pvpmod(varargin);

% --- preliminaries: checks
rmouse_APcheck;
rawCh=rmouse_chan;

% --- preliminaries: initialize figure
ftag='ccmov';
fh=findobj('tag',ftag);
if isempty(fh), fh=figure;
else  figure(fh);
end
tmpScrSz=get(0,'Screensize');
tmpScrSz=tmpScrSz*.8;
tmpScrSz(1)=tmpScrSz(1)+tmpScrSz(3)*.1;
tmpScrSz(2)=tmpScrSz(2)+tmpScrSz(4)*.1;  
set(fh,'position',tmpScrSz,...
  'tag',ftag,...
  'name',ftag,...
  'color',[0.27 0.27 .4],...
  'numbertitle','off');
clf;
orient landscape;

% --- preliminaries: graphics settings
labelscale('fontSz',7,'scaleFac',1.0,'lineW',1.5,'markSz',6); 
% set up compound colormap
nColors=128;
colormap([jet(nColors); coma('redblue','ncols',nColors)]);
% colormap([jet(nColors); coma('amberturquois','ncols',nColors)]);
% # of rows = # of CC types
nRows=length(strmTypes);
% # of cols = 2 (one for amplitude, one for lag)
nCols=2;
xmarg=.04;
ymarg=.035;
xpos=(0:nCols-1)*((1-2*xmarg)/nCols)+2*xmarg;
xlen=(1-2*xmarg)/nCols-2*xmarg;
% leave additional space (.05)for title subplot
ypos=fliplr((0:nRows-1)*((1-.05-2*ymarg)/nRows)+2*ymarg);
ylen=(1-.05-2*ymarg)/nRows-2*ymarg;
ccprop={'ampl','lag'};
cblabFstr={'%1.1f','%3.0f'};
% title 
subplot('position',[xmarg .95 1-2*xmarg .02]);
set(gca,'xlim',[0 1],'ylim',[0 1]);
axis off
th=text(.5,.5,'CC movie','fontsize',12,'fontweight','bold','horizontalalignment','center');

% --- preliminaries: useful vars, templates
nCh=nLFPCh;
rix=strmatch(beh,{r(:).segmentType});
% 3D master template
ccMatTemplate=repmat(nan,[nAllLFPCh nAllLFPCh r(rix).ni]);

for sti=1:nRows
  strmType=strmTypes{sti};
  switch strmType
    case 'delta'
      maxLag=250;
      minAmp=.0;
      % this stream's short form used in field of struct r
      STshort='de';
    case 'theta'
      maxLag=80;
      minAmp=.0;
      STshort='th';
    case 'thetaLoEnv'
      maxLag=180;
      minAmp=.0;
      % this stream's short form used in field of struct r
      STshort='thLoe';
    case 'thetaHiEnv'
      maxLag=180;
      minAmp=.0;
      % this stream's short form used in field of struct r
      STshort='thHie';
    case 'gamma'
      maxLag=15;
      minAmp=.0;
      % this stream's short form used in field of struct r
      STshort='ga';
    case 'gammaEnv'
      maxLag=15;
      minAmp=.0;
      % this stream's short form used in field of struct r
      STshort='gae';
    otherwise
      error('illegal streamType in CC matrix plot');
  end
end
% --- load variables & put in array
switch chanComb
  case 'princ'
    eval(['c=cat(1,r(rix).' STshort 'CCPeak{1:AP.LFPpcInd2,AP.LFPpcInd2});']);        
    eval(['c=cat(1,c,r(rix).' STshort 'CCPeak{AP.LFPpcInd2,AP.LFPpcInd2+1:end});']);        
    ccAmp=c; 
    eval(['c=cat(1,r(rix).' STshort 'CCPeakT{1:AP.LFPpcInd2,AP.LFPpcInd2});']);        
    % symmetry - don't forget to invert    
    c=c*(-1);
    eval(['c=cat(1,c,r(rix).' STshort 'CCPeakT{AP.LFPpcInd2,AP.LFPpcInd2+1:end});']);        
    c=c*(-1);    
    ccLag=c;
    c=[];
  case 'neigh'
    eval(['c=diag(r(rix).' STshort 'CCPeak,1);']);    
    ccAmp=cat(1,c{:});
    eval(['c=diag(r(rix).' STshort 'CCPeakT,1);']);    
    ccLag=cat(1,c{:});
    clear c
  case 'all'
    % the big scaling: since a colormap applies to a whole figure (and not a
    % single axis) we have to use a compound color map and scale the data such that
    % CC lags and amplitudes are converted to sets of nonoverlapping indices
    % 1. amplitudes: map [0 1] to [1 nColors]
    cFac(1)=nColors-1;
    cOffs(1)=1;
    % 2. lags: map [-maxLag maxLag] to [nColors+1 2*nColors]
    cFac(2)=(nColors-1)/(2*maxLag);
    cOffs(2)=cFac(1)+cOffs(1)+nColors/2;
    
    eval(['cm1=r(rix).' STshort 'CCPeak;']);
    eval(['cm2=r(rix).' STshort 'CCPeakT;']);
    ccLag=ccMatTemplate;
    ccAmp=ccMatTemplate;          
    % transfer values from cell array in array - has to be done elementwise because
    % there are empty cells & we're dealing with 3D arrays
    for rw=1:nAllLFPCh
      for cl=rw:nAllLFPCh
        ccAmp(rw,cl,:)=permute(cm1{rw,cl},[1 3 2]);
        ccLag(rw,cl,:)=permute(cm2{rw,cl},[1 3 2]);
      end
    end
    clear cm1 cm2
    % --- pruning, plucking, curbing
    % 1. amplitudes
    % CC peak values should be within [0 1], but to prevent indexing errors make
    % sure that is really so:
    ccAmp(ccAmp>1)=1;
    ccAmp(ccAmp<0)=0;
    ccAmp=round(cOffs(1)+cFac(1)*ccAmp);
    % 2. lags:
    % same story: deal with outliers (set to nan here)
    ccLag(abs(ccLag)>maxLag)=nan;
    ccLag=round(cOffs(2)+cFac(2)*ccLag);
end


switch chanComb
  case {'neigh','princ'}
    % set up subplots
    subplot(2,1,1);
    plot(ccAmp(:,1),'-o');
    child(1)=get(gca,'children');
    nicexyax;
    set(gca,'ylim',[0 1.1]);
    axis manual
    title('Nearest neighbor CC peak amplitudes');
    
    subplot(2,1,2);
    plot(ccLag(:,1),'-o');
    child(2)=get(gca,'children');    
    nicexyax;
    set(gca,'ylim',[-10 20]);
    axis manual
    title('Nearest neighbor CC peak lag');
      
    for k=1:r(rix).ni
      subplot(2,1,2);  
      set(child(1),'YData',(ccAmp(:,k))');
      subplot(2,1,2);  
      set(child(2),'YData',(ccLag(:,k))');
      drawnow;
      pause(.25)
    end      
    
  case 'all'
    % set up subplots
    ct=0;
    for sti=1:nRows
      for ii=1:2
        ct=ct+1;
        sph(ct)=subplot('position',[xpos(1+mod(ii-1,2)) ypos(sti) xlen ylen]);
        if ii==1
          ih(ct)=image(ccAmp(:,:,1));
        else
          ih(ct)=image(ccLag(:,:,1));
        end
        set(ih,'CDataMapping','direct')
        set(gca,'xaxisloc','top',...
          'ylim',[.5 nAllLFPCh+.5],'ytick',[1:nAllLFPCh],'yticklabel',WP.xtl2,...
          'xlim',[.5 nAllLFPCh+.5],'xtick',[1:nAllLFPCh],'xticklabel',WP.xtl2);
        axis manual
        axis square
        % inflate plots
        %rexy('xfac',1.4,'yfac',1.4);
        title([r(rix).segmentType ';' strmType ';' ccprop{ii}]);
      end
    end
    
    for k=1:r(rix).ni
      ct=0;
      for sti=1:nRows
        for ii=1:2
          ct=ct+1;
          subplot(sph(ct));
          if ii==1
            set(ih(ct),'CData',ccAmp(:,:,k));
          else
            set(ih(ct),'CData',ccLag(:,:,k));
          end
          % lines to indicate principal electrode
          lh=line(AP.LFPpcInd2*[1 1]',[.5 AP.LFPpcInd2]);
          set(lh,'color',[.6 .6 .6],'linestyle','-');
          lh=line([AP.LFPpcInd2 nAllLFPCh+.5],AP.LFPpcInd2*[1 1]');
          set(lh,'color',[.6 .6 .6],'linestyle','-');
          % in last frame put colorbar
          if k==r(rix).ni
            cbh=colorbar('vert');
            set(cbh,'ylim',[(ii-1)*nColors  ii*nColors]);
            % set ticks/labels at/to meaningful positions/values
            set(cbh,'ytick',[ii-1 ii-.5  ii]*nColors,...
              'yticklabel',num2str(((([ii-1 ii-.5  ii]*nColors)-cOffs(ii))/cFac(ii))',cblabFstr{ii}));
          end
        end
      end
      drawnow;
      pause(.05)
    end
end


% getframe
% movie