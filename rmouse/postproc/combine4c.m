function R=combine4c
% ** function R=combine4c
% The primary job this function does is to loop through a list of *.mat
% files produced by rmouse.m and to combine the data in them. The data
% files to be combined are listed in ANPAR and DSET, global variables which
% must be present when combine4b is called. ANPAR and DSET are struct
% arrays, concatenations of individual and matching(!) AP and DS. They are
% as a rule generated by simple routines in mfiles like collect_*. Their
% layout determines how the data will be combined: (i) one column per
% animal/experimental session (ii) one row per concentration (for
% pharmacological experiments), (iii) one 'slice' (3rd dimension) per
% genotype ** WARNING: function has not yet been tested on data sets with
% full dimensionality (pharmacological experiments on different genotypes)
% **
% 
% Furthermore, new parameters derived from raw results may be computed.
% Combined/generated data may be - written to auto.mat or cross.mat -
% 'exported' (in a more processed form, one mat file per analyzed
% parameter) - plotted in a crude format and saved in arbitrary graphics
% format - analyzed statistically with an F-test involving fitting
% functions to the data (à la Motusky)
% 
% The process of loading results from the 'raw' mat files can be bypassed
% and instead combine4c can access auto.mat or cross.mat computed
% previously. Needless to say that bypassing readin of data defeats the
% purpose of this function in case the raw results have changed in between.

% combine4c has been added in April 2020 for the then years reproducibility
% challenge, the major difference being that it and the functions it calls
% work without the curve fitting toolbox.


global ANPAR DSET WP AP DS

% options for function fitnlm
options = statset('MaxIter', 400, 'FunValCheck', 'on');

compareFactor(1).name='rec depth';
% levels of factor rec depth depend on the data
compareFactor(1).level={nan};
% which factor to compare, except recording site?
% - for each type of behavior, control will be compared with drug
compareFactor(2).name='drug'; 
compareFactor(2).level={nan};

% the project directory
projSubDir='\WTb3N265M';
projSubDir='\beta3_wtko';

% shall data & fits be exported? (one file per analysis parameter, for plot routines) 
export=1;
% export=0;
% print?
printas='-djpeg90';
printas=[];

curFigPath=[projSubDir '\figures'];

% choose electrode depth profile - physical or functional
dp='phys';'func';
% choose auto- or cross-channel results (cross not computed for theta, gamma env corr)
q='auto';
% q='cross';

% interpolate missing channels?
ipol=0;

% loading/saving compiled data: if loadFlag is nonzero and cross.mat or auto.mat
% exist, these will be loaded up, otherwise the data will be compiled from scratch.
% If writeflag is nonzero, cross.mat or auto.mat will be generated/overwritten
loadflag=0;
writeflag=1;

% choose behaviors to be compared/plotted (legal value of AP.segmentType)
behav={'immobile','exploring'};
% ..and corresponding symbols and colors for plots (colors first line)
bpset={[.6 .4 .1],[.5 1 .5];'s','o'};
% genotypes
gt={'WT';'KO'};
% ..and corresponding symbols and colors for plots (colors first line)
gtpset={'b','r';'o','s'};
% drug conditions
dr={'control';'atropine'};
% ..and corresponding symbols and colors for plots (colors first line)
drpset={'b','m';'o','s'};
% mm, limits of electrode depth (inclusive; slm=0, dorsal ones negative, ventral ones positive)
% ** june 22: for some strange reason, electrode depths are not equally spaced
% (specifically, what should be exactly 0.7 is in fact a number slightly
% higher). Hence the funny depthLim.
depthLim=[-.70001 0];
depthLim=[-.6 0];

% obtain results variable(s) to collect and average/plot
[rv,rvix]=set_rv(q);

% rv={'thPosPeakCvAMn',...
%   'thPosPeakCvIPIMn',... 
%   'thNegPeakCvAMn',...
%   'thNegPeakCvIPIMn'};
% rvix=1:4;
% 
rv={'thgaeCCPeakMn'};
rvix=1:1;

close all;
% multiple small figs
labelscale('fontSz',8,'scaleFac',.4,'lineW',.75,'markSz',5); 
% good if single figures are to be printed
labelscale('fontSz',12,'scaleFac',1.0,'lineW',1.5,'markSz',8); 

rmouse_ini;

% -------- PART I: collection of data
% it is important to load the ANPAR and DSET that generated the data in the matfile
if loadflag & exist([WP.rootPath projSubDir '\' q '.mat'],'file')
  load([WP.rootPath projSubDir '\' q '.mat'],'ANPAR','DSET');
end
[n1 n2 n3]=size(ANPAR);
[dn1 dn2 dn3]=size(DSET);
if ~isequal([n1 n2 n3],[dn1 dn2 dn3]), error('DSET and ANPAR must have equal dimension'); end

% struct holding collected results: R
tmplt=cell(length(behav),length(rv),n3);
tmplt(:)={[]};
% all of the following fields are 3d cell arrays:
% - row=behavior (in order listed above)
% - col=parameter (in order listed above)
% - slice=genotype (in order listed above)
% - each element of the cell array contains this type of data:
% collected data: 2d arr, 1st col electrode pos, 2nd col value (drug
% exprmnts: 3rd+ cols = values ar var. concentrations)
R.d=tmplt;          
% code for individual animal/session (needed for ANOVA with repeated
% measures and may be handy otherwise)
R.indv=tmplt;       
% 1d cell array; for each of the ue, these are the indices into the
% corresponding R.d
R.ueix=tmplt;       
% 'grand average': 2d arr, holding  mean|std|N
R.ga=tmplt;         

% this one's a 2D cell array, containing statistics for comparison among genotypes
% each element is a 1d array, for each electrode holding p-values etc 
R.bstat=tmplt(:,:,1); 

loadSuccess=0;
if loadflag & exist([WP.rootPath projSubDir '\' q '.mat'],'file')
  load([WP.rootPath projSubDir '\' q '.mat'],'R','bix');
  if exist('R','var')
    loadSuccess=1;
  end
else
  % loop over data sets: 
  % one experiment per column, concentration down the columns, different types of animals
  % (e.g. genotypes) in different slices
  for i3=1:n3
    for ci=1:n2
      for ri=1:n1
        AP=ANPAR(ri,ci,i3);
        DS=DSET(ri,ci,i3);
        % if one of the (indispensable) fields of DS isempty, the corresponding struct
        % element does not correspond to a data set 
        if ~isempty(DS.rawCh)
          rawCh=rmouse_chan;
          % let's make the reasonable assumption that for all data won in one experiment
          % the number of all LFP channes is invariant
          if ri==1
            % template (single data set)
            tempo=repmat(nan,AP.nAllLFPCh,1);
            % template (whole experiment)
            tempo2=repmat(tempo,1,n1);
          end
          % load results var..
          if isempty(strfind(AP.resPath,':')), AP.resPath=[WP.rootPath AP.resPath]; end    
          load([AP.resPath '\' AP.resFn],'r');
          % ..find behaviors..
          for bi=1:length(behav)
            bix(bi)=strmatch(behav{bi},{r(:).segmentType});
          end
          % ..and extract
          for bi=1:length(bix)
            for rvi=1:length(rv)
              % tell what we're dealing with 
              disp(['data: ' AP.resFn ', behavior: ' behav{bi} ', data:' rv{rvi}]);      
              % tmpr is the original data 
              eval(['tmpr=r(bix(bi)).' rv{rvi} ';']);
              if bi==1 & rvi==1 & ri==1
                % index into R.d rows
                elix=[1:AP.nAllLFPCh]+size(R.d{bi,rvi,i3},1);
              end
              % first data set: set up electrode position in first column
              if ri==1
                if strcmpi(dp,'phys')          
                  R.d{bi,rvi,i3}(elix,1)=WP.elx;
                elseif strcmpi(dp,'func')
                  R.d{bi,rvi,i3}(elix,1)=WP.felx;            
                end
              end
              y=[];
              % **********************************************************
              % select extraction method depending on results var chosen
              % **********************************************************
              switch rv{rvi}
                % these are the within-site correlations and derived
                % measures which are arrays (as opposed to cell arrays in
                % the case of all 'cross' measures)
                case {'thgaeCCPeakMn','thgaeCCPeakTMn','thgaeCCPeakPhaseMn','detheCCPeakMn',...
                    'detheCCPeakTMn','thgaeCCPosPeakDecayMn','thgaeCCZScore','thgaeCCZTestP',...
                    'thPosPeakCvAMn','thPosPeakCvIPIMn','thNegPeakCvAMn','thNegPeakCvIPIMn'}
                  if ~isempty(tmpr)
                    y=tempo;          
                    % ** special treatments: 
                    % - Z score and corresponding p-values: derive either means or 
                    % proportion of segments above criterion threshold as final measures
                    if strcmpi(rv{rvi},'thgaeCCZScore')
                      if 0
                        % Z>2.5 as criterion (corresponds to ~p=0.013): relative number of segments
                        % formula (look in ztest.m): p = 2 * normcdf(-abs(2.5),0,1)
                        nk=sum(isfinite(tmpr),1);
                        tmpr(~isfinite(tmpr))=0;
                        tmpr=sum(tmpr>2.5,1)./nk;
                      else
                        % new: compute mean (Z scores are normally
                        % distributed, in contrast to p values)
                        tmpr=nanmean(tmpr,1);
                      end
                    elseif strcmpi(rv{rvi},'thgaeCCZTestP')
                      % p<.01 as criterion: relative number of segments
                      nk=sum(isfinite(tmpr),1);
                      tmpr(~isfinite(tmpr))=1;
                      tmpr=sum(tmpr<.01,1)./nk;
                    end
                    y(AP.LFPccInd)=tmpr;
                  end
                otherwise % case <within-site CC?>
                  if length(celldiag(tmpr))>1
                    if strcmpi(q,'cross')
                      % extract CC data for principal channel: non analyzed channels 
                      % (nans) will be ignored on the plot
                      y=cat(1, tmpr{1:AP.LFPpcInd2,AP.LFPpcInd2});
                      y=[y; cat(1, tmpr{AP.LFPpcInd2,AP.LFPpcInd2+1:end})];
                    elseif strcmpi(q,'auto')
                      y=cat(1, tmpr{AP.dixie});              
                    end
                  end
              end % switch
              % concatenate all data sets: 1st col electrode pos, 2nd+ col values for
              % concentration in usual order (currently: control, drug, recovery)
              if isempty(y)
                warning(['data to be extracted do not exist']);
                R.d{bi,rvi,i3}(elix,ri+1)=tempo;    
                R.indv{bi,rvi,i3}(elix,1)=(i3-1)*100+ci;
              else
                % interpolate single missing electrodes??
                if ipol
                  % IMPORTANT: interpolation rests on the assumptions that
                  % - electrode spacing is equal among animals
                  % - depths are taken from a set of given values
                  % ==> electrode depths as specified in DS.rawCh must not have a gap
                  if strcmpi(dp,'func')
                    warndlg('interpolation of missing channel makes sense only if electrode depth profile (variable dp) is ''phys''');
                  else
                    % determine missing electrodes
                    if ~isempty(AP.LFPccOmitInd)
                      if length(AP.LFPccOmitInd)==1
                        disp(['interpolating missing channel:' DS.rawCh{AP.LFPccOmitInd,1}]);
                        figure(1), clf;
                        plot(WP.elx,y,'bo-');
                        hold on
                        y=interp1(WP.elx(AP.LFPccInd),y(AP.LFPccInd),WP.elx,'linear');
                        plot(WP.elx,y,'r+-');
                        drawnow;
                      else
                        warning([DS.abfFn ': more than one missing channel; no interpolation']);
                      end
                    end
                  end
                end % if:ipol
                % now insert
                R.d{bi,rvi,i3}(elix,ri+1)=y;
                % individual animal 'code': all wt=column order; all ko=100+column order 
                R.indv{bi,rvi,i3}(elix,1)=(i3-1)*100+ci;
              end % if:isempty(y)
            end % for:par
          end % for:behav
        end % if ~isempty(DS.rawCh)
      end % for:rows of ANPAR=concs
    end % for:cols of ANPAR=experiments
  end % for:slices of ANPAR=genotypes
end
% (r not needed anymore)
clear r

              
%               if isempty(y)
%                 warning(['data to be extracted do not exist']);
%                 R.d{bi,rvi,i3}(elix,ri+1)=tempo;          
%               else
%                 R.d{bi,rvi,i3}(elix,ri+1)=y;
%               end % if:isempty(y)
%               % individual animal 'code': all wt=column order; all ko=100+column order
%               R.indv{bi,rvi,i3}(elix,1)=(i3-1)*100+ci;
%             end % for:par
%           end % for:behav
%         end % if ~isempty(DS.rawCh)
%       end % for:rows of ANPAR=concs
%     end % for:cols of ANPAR=experiments
%   end % for:slices of ANPAR=genotypes
% end
% % (r not needed anymore)
% clear r

if ~loadSuccess
  % ------ PART II: find ue and get indices
  % (this is done separately in order to have grand averaging and statistics run independently of each other)
  for i3=1:n3
    for bi=1:length(bix)
      for rvi=1:length(rv)
        tmpr=R.d{bi,rvi,i3};
        % kick out all electrodes with any nan
        badix=find(any(~isfinite(tmpr),2));
        if ~isempty(badix),
          disp([int2str(length(badix)) ' entries are NaNs']);
          tmpr(badix,:)=[];
          R.d{bi,rvi,i3}(badix,:)=[];
          R.indv{bi,rvi,i3}(badix,:)=[];
        end
        % electrode positions
        ue=unique(tmpr(:,1));
        % which we need to keep (although within behaviors and analysis parameters
        % of one group of animals no variance is expected)
        R.ue{bi,rvi,i3}=ue;
        % preallocate R.ga
        % dimensions: #electrodes | #parameters (mean,std,N)  | #conc (control,drug,recovery)
        R.ga{bi,rvi,i3}=repmat(nan,[length(ue),3,n1]);
        % preallocation of R.bstat makes no sense here
        ix={};
        for ei=1:length(ue)
          ix{ei}=find(tmpr(:,1)==ue(ei));
        end
        R.ueix{bi,rvi,i3}=ix;
      end
    end
  end

  % ------ PART III: grand averages
  for i3=1:n3
    for bi=1:length(bix)
      for rvi=1:length(rv)
        % compute averages and std (nans had been kicked out before)
        tmpr=R.d{bi,rvi,i3};
        % the order of elements in R.ueix{bi,rvi,i3} corresponds to that in R.ue{bi,rvi,i3}
        for ei=1:length(R.ueix{bi,rvi,i3})
          ix=R.ueix{bi,rvi,i3}{ei};
          % columns: mean|std|N; slices: control|drug|recovery
          R.ga{bi,rvi,i3}(ei,1,:)=reshape(mean(tmpr(ix,2:end),1),[1 1 n1]);
          R.ga{bi,rvi,i3}(ei,2,:)=reshape(std(tmpr(ix,2:end),0,1),[1 1 n1]);
          R.ga{bi,rvi,i3}(ei,3,:)=repmat(length(ix),[1 1 n1]);
        end
      end
    end
  end
end % if ~loadSuccess

% save results up to here?
if writeflag
  switch q
    case 'auto'
      save auto R ANPAR DSET behav bix rv q
    case 'cross'
      save cross R ANPAR DSET behav bix rv q
  end
end

switch compareFactor(2).name
  case 'genotype'
    loopP=bix;
    pset=gtpset;
  case 'behavior'
    % there are only two genotypes
    loopP=1:length(gt);
    pset=bpset;    
  case 'drug'
    % 'drug' is very much like 'genotype'
    loopP=bix;
    pset=drpset;    
  otherwise
    error('illegal choice of factor');
end

if ischar(rvix), rvix=length(rv):-1:1; end
% ------ PART IV: curve fitting for the sake of statistics 
for rvi=rvix
  figure(rvi), orient landscape
  % loop either over behaviors (comparison of genotypes) or genotypes (comparison of behaviors)
  for loopi=1:length(loopP)  
    % --- part 1: collect data, restrict to recording sites dorsal of & including SLM and
    % invert x axis so that independent var has values >=0
    % - data sets:
    switch compareFactor(2).name
      case 'genotype'
        ds1=R.d{loopi,rvi,1};
        ds2=R.d{loopi,rvi,2};
        error('''indv'' var not yet set up');
      case 'behavior'        
        ds1=R.d{1,rvi,loopi};
        ds2=R.d{2,rvi,loopi};
        error('''indv'' var not yet set up');
      case 'drug'        
        ds1=R.d{loopi,rvi,1}(:,[1 2]);
        ds2=R.d{loopi,rvi,1}(:,[1 3]);
        indv1=R.indv{loopi,rvi};
        indv2=R.indv{loopi,rvi};
    end
    % restrict depth range
    tmpix=ds1(:,1)<depthLim(1) | ds1(:,1)>depthLim(2);
    ds1(tmpix,:)=[];
    indv1(tmpix)=[];
    tmpix=ds2(:,1)<depthLim(1) | ds2(:,1)>depthLim(2);
    ds2(tmpix,:)=[];
    indv2(tmpix)=[];

    % invert sign
    ds1(:,1)=ds1(:,1)*-1;
    ds2(:,1)=ds2(:,1)*-1;
    % sort
    [ds1,tmpix]=sortrows(ds1,1);
    indv1=indv1(tmpix);
    [ds2,tmpix]=sortrows(ds2,1);
    indv2=indv2(tmpix);
    % - combination of both (only needed here, not for export)
    ds12=sortrows([ds1; ds2]);
    
    % for plots of average data points (that is, the original grand averages) do the same
    % thing (+shuffle & combine columns so that the resulting var has pos|mean|std cols):
    % data sets:
    switch compareFactor(2).name
      case 'genotype'
        mds1=[R.ue{loopi,rvi,1} R.ga{loopi,rvi,1}(:,1:2)];
        mds2=[R.ue{loopi,rvi,2} R.ga{loopi,rvi,2}(:,1:2)];
        titl=[behav{loopi} ', ' rv{rvi} ', ' q];
        fnp=[behav{loopi} '_' rv{rvi} '_' q];
        compareFactor(2).level=gt;
      case 'behavior'        
        mds1=[R.ue{1,rvi,loopi} R.ga{1,rvi,loopi}(:,1:2)];
        mds2=[R.ue{2,rvi,loopi} R.ga{2,rvi,loopi}(:,1:2)];
        titl=[gt{loopi} ', ' rv{rvi} ', ' q];
        fnp=[gt{loopi} '_' rv{rvi} '_' q];
        compareFactor(2).level=behav;
      case 'drug'
        mds1=[R.ue{loopi,rvi,1} R.ga{loopi,rvi,1}(:,1:2,1)];
        mds2=[R.ue{loopi,rvi,1} R.ga{loopi,rvi,1}(:,1:2,2)];
        titl=['wt, comprsn drug, ' behav{loopi} ', ' rv{rvi} ', ' q];
        fnp=[behav{loopi} '_' rv{rvi} '_' q]
        compareFactor(2).level=dr;
    end
    % restrict depth range
    mds1(mds1(:,1)<depthLim(1) | mds1(:,1)>depthLim(2),:)=[];
    mds2(mds2(:,1)<depthLim(1) | mds2(:,1)>depthLim(2),:)=[];
    % invert sign
    mds1(:,1)=mds1(:,1)*-1;
    mds2(:,1)=mds2(:,1)*-1;
    
    % --- part 2: depending on parameter transform data and set up model
    [funH, fitParNames, beta, ds1ix, ds2ix, ds12ix]=fit2rmousepar(ds1, ds2, ds12, rv{rvi});
    
    % --- part 3: fit and determine quality of fit for wt and ko
    [fitPar1, stats1] = fitnlm_e(ds1(ds1ix,1), ds1(ds1ix,2), funH, beta, options);
    [fitPar2, stats2] = fitnlm_e(ds2(ds2ix,1), ds2(ds2ix,2), funH, beta, options);
    [fitPar12, stats12] = fitnlm_e(ds12(ds12ix,1), ds12(ds12ix,2), funH, beta, options);
    
%     set(fo_,'Startpoint',st_);
%     ds1f=fit(ds1(ds1ix,1),ds1(ds1ix,2),ft_ ,fo_);    
%     ds2f=fit(ds2(ds2ix,1),ds2(ds2ix,2),ft_ ,fo_);
%     ds12f=fit(ds12(ds12ix,1),ds12(ds12ix,2),ft_ ,fo_);
    
    % --- part 4: create curves representing the fits & plot
    % 1. all data pts & fit
    fitx=ds12(1,1):(ds12(end,1)-ds12(1,1))/200:ds12(end,1);

    % cfit objects will be 'fevaluated' automatically
    ds1fit=funH(fitPar1', fitx);
    ds2fit=funH(fitPar2', fitx);
    ds12fit=funH(fitPar12', fitx);
    
    % -----------------interlude: export data?
    if export
      fn=[mfilename '_' compareFactor(2).name(1:4) '_' fnp];
      save([WP.rootPath projSubDir '\intermediate_data\' fn],'compareFactor','ds1','ds2','mds*','ds1fit','ds2fit','fitx','indv*');
    end
    % -------------------------------------
    subplot(length(loopP),2,(loopi-1)*2+1), hold on
    title(titl);
    % first
    ph=plot(ds1(:,1),ds1(:,2),pset{2,1});
    set(ph,'color',pset{1,1});
    ph=plot(fitx,ds1fit,'-');
    set(ph,'color',pset{1,1});    
    % second
    ph=plot(ds2(:,1),ds2(:,2),pset{2,2});
    set(ph,'color',pset{1,2});
    ph=plot(fitx,ds2fit,'-');
    set(ph,'color',pset{1,2});        
    % combo fit in black
    plot(fitx,ds12fit,'k-');
    nicexyax;
    % 2. averages & fit
    subplot(length(loopP),2,(loopi-1)*2+2), hold on
    ph=errorbar(mds1(:,1),mds1(:,2),mds1(:,3),pset{2,1});
    set(ph,'color',pset{1,1});
    ph=plot(fitx,ds1fit,'-');
    set(ph,'color',pset{1,1});    
    ph=errorbar(mds2(:,1),mds2(:,2),mds2(:,3),pset{2,2});
    set(ph,'color',pset{1,2});
    ph=plot(fitx,ds2fit,'-');
    set(ph,'color',pset{1,2});    
    niceyax;

%     % --- part 5: F-test
%     % statistical test for similarity (order: wt crf, ko crf, combo crf)
%     [p,F,radj1,radj2]=curvecomp([ds1(ds1ix,:) ds1f(ds1(ds1ix,1))], ...
%                                 [ds2(ds2ix,:) ds2f(ds2(ds2ix,1))],...
%                                 [ds12(ds12ix,:) ds12f(ds12(ds12ix,1))],...
%                                 length(ds1ix)-length(st_),length(ds2ix)-length(st_));
% 
%     urtext(['p=' num2str(p,'%1.3f')],.85,'fontsize',12);
%     if p<.05
%       disp(['***** H0 (identity of depth-response profiles) rejected, p= ' num2str(p)]); 
%     else
%       disp(['H0 (identity of depth-response profiles) not rejected, p= ' num2str(p)]);               
%     end
%     % information on goodness of fit
%     ultext(['R_{adj}(1):' num2str(radj1,3) '; R_{adj}(2):' num2str(radj2,3)]);
%     ds1f
%     ds2f
%     ds12f
  
  end % for: behaviors

  if ~isempty(printas)
    print(printas,[WP.rootPath curFigPath '\' compareFactor(2).name(1:4) '_' rv{rvi} '_' q '_fit.jpg']); 
    % saveas(gcf,[WP.rootPath curFigPath '\' rv{rvi} '_' q '_fit'],'fig');
  end
end % for: parameters



function [fitPar, stats] = fitnlm_e(x, y, funH, beta, options)
% wrapper for fitnlm with specific outputs
if ~isempty(options)
    mdl = fitnlm(x, y, funH, beta, 'Options', options);
else
    mdl = fitnlm(x, y, funH, beta);
end
fitPar = mdl.Coefficients.Estimate;
stats = mdl.Rsquared.Adjusted;
    
