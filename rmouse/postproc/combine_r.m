function combine_r(RInfo,rfn,fh_set_rv)
% ** function combine_r(RInfo,rfn,fh_set_rv)
% The primary job this function does is to loop through a list of *.mat
% files produced by rmouse.m and to combine the data in them. The data
% files to be combined are listed in ANPAR and DSET, global variables which
% must be present when combine_r is called. ANPAR and DSET are struct
% arrays, concatenations of individual and matching(!) AP and DS. They are
% as a rule generated by simple routines in mfiles like collect_*. Their
% layout determines how the data will be combined: (i) one column per
% animal/experimental session (ii) one row per concentration (for
% pharmacological experiments), (iii) one 'slice' (3rd dimension) per
% genotype 
% Furthermore, new parameters derived from raw results may be computed.

% improvements:
% - make this a shiny GUI?

global DSET ANPAR DS AP WP

if nargin<3
  % default set_rv function
  fh_set_rv=@set_rv;
end
if nargin<2
  % generic name of file to save data in
  rfn=['out_' mfilename];
end

% choose electrode depth profile - physical or functional
% dp='func';
dp='phys';

% interpolate missing channels?
ipol=0;

% need a shorty for behavior which is inherently a factor in rmouse data
behav=RInfo(strmatch('behavior',{RInfo.name})).level;

% obtain results variables (rv) to collect 
rv_auto=fh_set_rv('auto');
rv_cross=fh_set_rv('cross');
rv=cat(1,rv_auto,rv_cross);
% what type are they
rType=cat(1,repmat({'auto'},length(rv_auto),1),repmat({'cross'},length(rv_cross),1));

rmouse_ini;

% -------- PART I: collection of data
[n1 n2 n3]=size(ANPAR);
[dn1 dn2 dn3]=size(DSET);
if ~isequal([n1 n2 n3],[dn1 dn2 dn3]), error('DSET and ANPAR must have equal dimension'); end

% struct holding collected results: R
tmplt=cell(length(behav),length(rv),n3);
tmplt(:)={[]};
% all of the following fields are 3d cell arrays:
% - row=behavior (in order listed above)
% - col=parameter (in order listed above)
% - slice=genotype (in order listed above)
% - each element of the cell array contains this type of data:
% collected data: 2d arr, 1st col electrode pos, 2nd col value (drug
% exprmnts: 3rd+ cols = values ar var. concentrations)
R.d=tmplt;          
% code for individual animal/session (needed for ANOVA with repeated
% measures and may be handy otherwise)
R.indv=tmplt;       
% 1d cell array; for each of the ue, these are the indices into the
% corresponding R.d
R.ueix=tmplt;       
% 'grand average': 2d arr, holding  mean|std|N
R.ga=tmplt;         


% loop over data sets:
% one experiment per column, concentration down the columns, different types of animals
% (e.g. genotypes) in different slices
for i3=1:n3
  for ci=1:n2
    for ri=1:n1
      AP=ANPAR(ri,ci,i3);
      DS=DSET(ri,ci,i3);
      % if one of the (indispensable) fields of DS isempty, the corresponding struct
      % element does not correspond to a data set
      if ~isempty(DS.rawCh)
        rawCh=rmouse_chan;
        % let's make the reasonable assumption that for all data won in one experiment
        % the number of all LFP channes is invariant
        if ri==1
          % template (single data set)
          tempo=repmat(nan,AP.nAllLFPCh,1);
          % template (whole experiment)
          tempo2=repmat(tempo,1,n1);
        end
        % load results var..
        if isempty(strfind(AP.resPath,':'))
          AP.resPath=[WP.rootPath AP.resPath]; 
        end
        load([AP.resPath '\' AP.resFn],'r');
        % ..find behaviors..
        for bi=1:length(behav)
          bix(bi)=strmatch(behav{bi},{r(:).segmentType});
          disp([int2str(r(4).ni) ' segments during exploring behavior'])
        end
        % ..and extract
        for bi=1:length(bix)
          for rvi=1:length(rv)
            % tell what we're dealing with
            disp(['data: ' AP.resFn ', behavior: ' behav{bi} ', # segments: ' int2str(r(bix(bi)).ni) ', parameter:' rv{rvi}]);
            % tmpr is the original data
            tmpr=eval(['r(bix(bi)).' rv{rvi} ';']);
            if bi==1 && rvi==1 && ri==1
              % index into R.d rows
              elix=[1:AP.nAllLFPCh]+size(R.d{bi,rvi,i3},1);
            end
            % first data set: set up electrode position in first column
            if ri==1
              if strcmpi(dp,'phys')
                R.d{bi,rvi,i3}(elix,1)=WP.elx;
              elseif strcmpi(dp,'func')
                R.d{bi,rvi,i3}(elix,1)=WP.felx;
              end
            end
            y=[];
            % **********************************************************
            % select extraction method depending on results var chosen
            % **********************************************************
%             rawgaeCohPeak: [1x15x15 double]
%             rawgaeCohPeakF: [1x15x15 double]
%             rawgaeCohTh: [1x15x15 double]
            
            
            switch rv{rvi}
              % these are the within-site correlations and derived
              % measures which are arrays (as opposed to cell arrays in
              % the case of all 'cross' measures)
              case {'thgaeCCPeakMn','thgaeCCPeakTMn','thgaeCCPeakPhaseMn',...
                  'thgaeCCPeakStd','thgaeCCPeakTStd','thgaeCCPeakPhaseStd',...
                  'thgaeCCZScore','thgaeCCZTestP',...
                  'thgaeCCEnvPeakMn','thgaeCCEnvPeakTMn','thgaeCCEnvPeakPhaseMn',...
                  'thgaeCCEnvPeakStd','thgaeCCEnvPeakTStd','thgaeCCEnvPeakPhaseStd',...
                  'thgaeCCEnvZScore','thgaeCCEnvZTestP',...
                  'thgaeCCPosPeakDecayMn','thgaeCCPosPeakDecayStd',...
                  'thPosPeakCvAMn','thPosPeakCvIPIMn','thNegPeakCvAMn','thNegPeakCvIPIMn',...
                  'gaePosPeakCvAMn','gaePosPeakCvIPIMn','gaeNegPeakCvAMn','gaeNegPeakCvIPIMn',...
                  'detheCCPeakMn','detheCCPeakTMn'}
                if ~isempty(tmpr)
                  y=tempo;
                  % ** special treatments:
                  % - Z score and corresponding p-values: derive either means or
                  % proportion of segments above criterion threshold as final measures
                  if strcmpi(rv{rvi},'thgaeCCZScore') || strcmpi(rv{rvi},'thgaeCCEnvZScore')
                    if 0
                      % Z>2.5 as criterion (corresponds to ~p=0.013): relative number of segments
                      % formula (look in ztest.m): p = 2 * normcdf(-abs(2.5),0,1)
                      nk=sum(isfinite(tmpr),1);
                      tmpr(~isfinite(tmpr))=0;
                      tmpr=sum(tmpr>2.5,1)./nk;
                    else
                      % new: compute mean (Z scores are normally
                      % distributed, in contrast to p values)
                      tmpr=nanmean(tmpr,1);
                    end
                  elseif strcmpi(rv{rvi},'thgaeCCZTestP') || strcmpi(rv{rvi},'thgaeCCEnvZTestP')
                    % p<.01 as criterion: relative number of segments
                    nk=sum(isfinite(tmpr),1);
                    tmpr(~isfinite(tmpr))=1;
                    tmpr=sum(tmpr<.01,1)./nk;
                  end
                  y(AP.LFPccInd)=tmpr;
                end
              case {'rawgaeCohPeak','rawgaeCohPeakF','rawgaeCohTh'}
                % these results parameters deserve special treatment: the
                % results reside in 3D arrays with non-redundant entries on
                % either side of the 'main diagonal'
                if numel(tmpr)>1
                  % permute dimensions of tmpr
                  tmpr=permute(tmpr,[2 3 1]);
                  if strcmpi(rType{rvi},'cross')
                    % extract data for principal channel
                    y=tmpr(1:AP.LFPpcInd2,AP.LFPpcInd2);
                    y=[y; tmpr(AP.LFPpcInd2,AP.LFPpcInd2+1:end)'];
                  elseif strcmpi(rType{rvi},'auto')
                    y=tmpr(AP.dixie)';
                  end
                end
              otherwise 
                if length(celldiag(tmpr))>1
                  if strcmpi(rType{rvi},'cross')
                    % extract CC data for principal channel: non analyzed channels
                    % (nans) will be ignored on the plot
                    y=cat(1, tmpr{1:AP.LFPpcInd2,AP.LFPpcInd2});
                    y=[y; cat(1, tmpr{AP.LFPpcInd2,AP.LFPpcInd2+1:end})];
                  elseif strcmpi(rType{rvi},'auto')
                    y=cat(1, tmpr{AP.dixie});
                  end
                end
            end % switch
            % concatenate all data sets: 1st col electrode pos, 2nd+ col values for
            % concentration in usual order (currently: control, drug, recovery)
            if isempty(y)
              warning(['data to be extracted do not exist']);
              R.d{bi,rvi,i3}(elix,ri+1)=tempo;
              R.indv{bi,rvi,i3}(elix,1)=(i3-1)*100+ci;
            else
              % interpolate single missing electrodes??
              if ipol
                % IMPORTANT: interpolation rests on the assumptions that
                % - electrode spacing is equal among animals
                % - depths are taken from a set of given values
                % ==> electrode depths as specified in DS.rawCh must not have a gap
                if strcmpi(dp,'func')
                  warndlg('interpolation of missing channel makes sense only if electrode depth profile (variable dp) is ''phys''');
                else
                  % determine missing electrodes
                  if ~isempty(AP.LFPccOmitInd)
                    if length(AP.LFPccOmitInd)==1
                      disp(['interpolating missing channel:' DS.rawCh{AP.LFPccOmitInd,1}]);
                      figure(1), clf;
                      plot(WP.elx,y,'bo-');
                      hold on
                      y=interp1(WP.elx(AP.LFPccInd),y(AP.LFPccInd),WP.elx,'linear');
                      plot(WP.elx,y,'r+-');
                      drawnow;
                    else
                      warning([DS.abfFn ': more than one missing channel; no interpolation']);
                    end
                  end
                end
              end % if:ipol
              % now insert
              R.d{bi,rvi,i3}(elix,ri+1)=y;
              % individual animal 'code': all wt=column order; all ko=100+column order
              R.indv{bi,rvi,i3}(elix,1)=(i3-1)*100+ci;
            end % if:isempty(y)
          end % for:par
        end % for:behav
      end % if ~isempty(DS.rawCh)
    end % for:rows of ANPAR=concs
  end % for:cols of ANPAR=experiments
end % for:slices of ANPAR=genotypes
% (r not needed anymore)
clear r

% save the 'raw' R with lots of nans in it (missing values)
Rraw=R;
% ...but get rid of empty fields in Rraw
Rraw=rmfield(Rraw,{'ga','ueix'});
% ------------------------------------------------------------------------
% The basic job of collecting data is done here. Parts II and III 
% prune the data in a specific way, compute grand averages and 'unique
% electrodes' etc.; they are left in place to ensure compatibility of R
% with older code that relies on these.
% ------------------------------------------------------------------------
% % ------ PART II: find ue and get indices
% % (this is done separately in order to have grand averaging and statistics run independently of each other)
% for i3=1:n3
%   for bi=1:length(bix)
%     for rvi=1:length(rv)
%       tmpr=R.d{bi,rvi,i3};
%       % kick out all electrodes with any nan (=missing data for any of the
%       % recorded drug concentrations). 
%       % *** Note that this is somewhat arbitrary because missing values for
%       % other parameters (e.g. behavior) are treated differently ***
%       badix=find(any(~isfinite(tmpr),2));
%       if ~isempty(badix),
%         disp([int2str(length(badix)) ' entries are NaNs']);
%         tmpr(badix,:)=[];
%         R.d{bi,rvi,i3}(badix,:)=[];
%         R.indv{bi,rvi,i3}(badix,:)=[];
%       end
%       % electrode positions
%       ue=unique(tmpr(:,1));
%       % which we need to keep (although within behaviors and analysis parameters
%       % of one group of animals no variance is expected)
%       R.ue{bi,rvi,i3}=ue;
%       % preallocate R.ga
%       % dimensions: #electrodes | #parameters (mean,std,N)  | #conc (control,drug,recovery)
%       R.ga{bi,rvi,i3}=repmat(nan,[length(ue),3,n1]);
%       ix={};
%       for ei=1:length(ue)
%         ix{ei}=find(tmpr(:,1)==ue(ei));
%       end
%       R.ueix{bi,rvi,i3}=ix;
%     end
%   end
% end
% 
% % ------ PART III: grand averages
% for i3=1:n3
%   for bi=1:length(bix)
%     for rvi=1:length(rv)
%       % compute averages and std (nans had been kicked out before)
%       tmpr=R.d{bi,rvi,i3};
%       % the order of elements in R.ueix{bi,rvi,i3} corresponds to that in R.ue{bi,rvi,i3}
%       for ei=1:length(R.ueix{bi,rvi,i3})
%         ix=R.ueix{bi,rvi,i3}{ei};
%         % columns: mean|std|N; slices: control|drug|recovery
%         R.ga{bi,rvi,i3}(ei,1,:)=reshape(mean(tmpr(ix,2:end),1),[1 1 n1]);
%         R.ga{bi,rvi,i3}(ei,2,:)=reshape(std(tmpr(ix,2:end),0,1),[1 1 n1]);
%         R.ga{bi,rvi,i3}(ei,3,:)=repmat(length(ix),[1 1 n1]);
%       end
%     end
%   end
% end

% ------ PART IV: save
% append 'auto' or 'cross' specifier to rv 
for rvi=1:length(rv)
  rv{rvi}=[rv{rvi} '_' rType{rvi}];
end
% save(rfn,'R','Rraw','ANPAR','DSET','RInfo','rv');
save(rfn,'Rraw','ANPAR','DSET','RInfo','rv');

